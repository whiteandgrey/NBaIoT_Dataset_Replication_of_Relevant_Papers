# ç®—æ³•å®ç°åˆ†æä¸éªŒè¯æŠ¥å‘Š

## 1. çª—å£å¤§å°è®¡ç®—é€»è¾‘éªŒè¯

### 1.1 ç®—æ³•å®ç°åŸç†

**æ ¸å¿ƒç®—æ³•**ï¼šæ»‘åŠ¨çª—å£å¤šæ•°æŠ•ç¥¨æœºåˆ¶

**å®ç°ä½ç½®**ï¼š
- `anomaly_detector.py` ç¬¬169-215è¡Œï¼š`optimize_window_size()`æ–¹æ³•
- `anomaly_detector.py` ç¬¬121-167è¡Œï¼š`calculate_fpr_with_window()`æ–¹æ³•

**ç®—æ³•æµç¨‹**ï¼š

1. **è®¡ç®—å¼‚å¸¸é˜ˆå€¼ tr***ï¼š
   ```python
   # åœ¨DSoptæ•°æ®é›†ä¸Šè®¡ç®—MSE
   mse_values = self.calculate_reconstruction_error(dsopt_data)
   
   # è®¡ç®—å‡å€¼å’Œæ ‡å‡†å·®
   mean_mse = np.mean(mse_values)
   std_mse = np.std(mse_values)
   
   # è®¡ç®—é˜ˆå€¼
   tr_threshold = mean_mse + std_mse
   ```

2. **ç”Ÿæˆåˆå§‹å¼‚å¸¸å†³ç­–**ï¼š
   ```python
   # ç”Ÿæˆåˆå§‹å¼‚å¸¸å†³ç­–ï¼ˆ>tr*=1ï¼Œå¦åˆ™=0ï¼‰
   anomaly_decisions = (mse_values > tr_threshold).astype(int)
   
   # DSoptå…¨éƒ¨æ˜¯è‰¯æ€§æ•°æ®ï¼ŒçœŸå®æ ‡ç­¾å…¨ä¸º0
   true_labels = np.zeros(len(dsopt_data), dtype=int)
   ```

3. **æ»‘åŠ¨çª—å£å¤šæ•°æŠ•ç¥¨**ï¼š
   ```python
   for i in range(n_samples):
       start = max(0, i - window_size + 1)
       window = anomaly_decisions[start:i+1]
       if len(window) >= window_size // 2:
           # å¤šæ•°æŠ•ç¥¨
           window_decision = 1 if sum(window) > len(window) / 2 else 0
       else:
           # çª—å£å¤ªå°ï¼Œç›´æ¥ä½¿ç”¨å½“å‰å†³ç­–
           window_decision = anomaly_decisions[i]
       windowed_decisions.append(window_decision)
   ```

4. **ä¼˜åŒ–çª—å£å¤§å°**ï¼š
   ```python
   # å¯»æ‰¾æœ€å°çš„çª—å£å¤§å°
   max_window_size = min(100, len(dsopt_data))
   best_window_size = max_window_size
   
   for window_size in range(1, max_window_size + 1):
       fpr = self.calculate_fpr_with_window(anomaly_decisions, true_labels, window_size)
       
       if fpr == 0.0:
           best_window_size = window_size
           break
   ```

### 1.2 çª—å£å¤§å°é¢‘ç¹è®¡ç®—ä¸º100çš„æ ¹æœ¬åŸå› 

**åŸå› åˆ†æ**ï¼š

1. **DSoptæ•°æ®é›†ä¸Šçš„åˆå§‹å¼‚å¸¸å€™é€‰æ•°é‡è¾ƒå¤š**ï¼š
   - å¦‚æœDSoptæ•°æ®é›†ä¸Šçš„é‡å»ºè¯¯å·®åˆ†å¸ƒè¾ƒå¹¿
   - åˆå§‹å¼‚å¸¸å€™é€‰æ•°é‡ï¼ˆmse_values > tr_thresholdï¼‰å¯èƒ½è¾ƒé«˜
   - éœ€è¦è¾ƒå¤§çš„çª—å£å¤§å°æ‰èƒ½é€šè¿‡å¤šæ•°æŠ•ç¥¨æ¶ˆé™¤è¯¯æŠ¥

2. **max_window_sizeé™åˆ¶**ï¼š
   ```python
   max_window_size = min(100, len(dsopt_data))
   ```
   - å½“å‰å®ç°å°†æœ€å¤§çª—å£å¤§å°é™åˆ¶ä¸º100
   - å¦‚æœåœ¨çª—å£å¤§å°100ä¹‹å‰æ— æ³•è¾¾åˆ°0%è¯¯æŠ¥ç‡ï¼Œåˆ™è¿”å›100

3. **å¤šæ•°æŠ•ç¥¨æœºåˆ¶çš„å±€é™æ€§**ï¼š
   - å½“çª—å£å¤§å°ä¸º100æ—¶ï¼Œéœ€è¦è¶…è¿‡50ä¸ªå¼‚å¸¸å†³ç­–æ‰èƒ½åˆ¤å®šä¸ºå¼‚å¸¸
   - å¦‚æœåˆå§‹å¼‚å¸¸å€™é€‰æ•°é‡è¾ƒå¤šä¸”åˆ†å¸ƒè¾ƒå¹¿ï¼Œéœ€è¦æ›´å¤§çš„çª—å£æ‰èƒ½æ¶ˆé™¤è¯¯æŠ¥

**éªŒè¯å»ºè®®**ï¼š

1. **å¢åŠ max_window_sizeé™åˆ¶**ï¼š
   ```python
   # å½“å‰å®ç°
   max_window_size = min(100, len(dsopt_data))
   
   # å»ºè®®ä¿®æ”¹
   max_window_size = min(500, len(dsopt_data))  # å¢åŠ åˆ°500
   ```

2. **æ·»åŠ è¯¦ç»†çš„çª—å£å¤§å°ä¼˜åŒ–æ—¥å¿—**ï¼š
   ```python
   for window_size in range(1, max_window_size + 1):
       fpr = self.calculate_fpr_with_window(anomaly_decisions, true_labels, window_size)
       
       # æ‰“å°æ¯ä¸ªçª—å£å¤§å°çš„FPR
       print(f"   Window size {window_size}: FPR = {fpr:.4f}, Anomalies = {sum(windowed_decisions)}")
       
       if fpr == 0.0:
           best_window_size = window_size
           print(f"âœ… Found optimal window size ws* = {best_window_size}")
           break
   ```

3. **åˆ†æDSoptæ•°æ®é›†çš„MSEåˆ†å¸ƒ**ï¼š
   ```python
   # æ·»åŠ MSEåˆ†å¸ƒåˆ†æ
   print(f"ğŸ“Š MSE distribution analysis:")
   print(f"   Percentiles:")
   for p in [50, 75, 90, 95, 99]:
       print(f"   {p}th percentile: {np.percentile(mse_values, p):.6f}")
   print(f"   Threshold tr*: {tr_threshold:.6f}")
   print(f"   Samples above threshold: {sum(mse_values > tr_threshold)} ({sum(mse_values > tr_threshold)/len(mse_values)*100:.2f}%)")
   ```

### 1.3 çª—å£æŠ•ç¥¨æœºåˆ¶çš„åº•å±‚å®ç°åŸç†

**æŠ•ç¥¨è§„åˆ™**ï¼š
- å¤šæ•°æŠ•ç¥¨ï¼šå¦‚æœçª—å£å†…å¼‚å¸¸å†³ç­–æ•°é‡ > çª—å£å¤§å°/2ï¼Œåˆ™åˆ¤å®šä¸ºå¼‚å¸¸
- çª—å£å¤§å°ä¸è¶³ï¼šå¦‚æœçª—å£å¤§å° < window_size // 2ï¼Œç›´æ¥ä½¿ç”¨å½“å‰å†³ç­–

**æƒé‡åˆ†é…**ï¼š
- å½“å‰å®ç°ï¼šæ‰€æœ‰çª—å£å†…çš„å†³ç­–æƒé‡ç›¸ç­‰ï¼ˆç®€å•å¤šæ•°æŠ•ç¥¨ï¼‰
- æ”¹è¿›å»ºè®®ï¼šå¯ä»¥è€ƒè™‘åŠ æƒæŠ•ç¥¨ï¼Œè¶Šè¿‘çš„å†³ç­–æƒé‡è¶Šé«˜

**é˜ˆå€¼è®¾å®š**ï¼š
- å½“å‰é˜ˆå€¼ï¼šçª—å£å¤§å°/2
- æ”¹è¿›å»ºè®®ï¼šå¯ä»¥è€ƒè™‘åŠ¨æ€é˜ˆå€¼ï¼Œæ ¹æ®çª—å£å†…å¼‚å¸¸å†³ç­–çš„åˆ†å¸ƒè°ƒæ•´

**æ•°å­¦ä¸¥è°¨æ€§éªŒè¯**ï¼š

1. **å¤šæ•°æŠ•ç¥¨çš„æ­£ç¡®æ€§**ï¼š
   - å‡è®¾çª—å£å¤§å°ä¸ºNï¼Œéœ€è¦è¶…è¿‡N/2ä¸ªå¼‚å¸¸å†³ç­–æ‰èƒ½åˆ¤å®šä¸ºå¼‚å¸¸
   - è¿™ç¡®ä¿äº†å†³ç­–çš„ç¨³å®šæ€§ï¼Œå‡å°‘äº†å•ä¸ªå¼‚å¸¸å†³ç­–çš„å½±å“

2. **çª—å£å¤§å°ä¸è¯¯æŠ¥ç‡çš„å…³ç³»**ï¼š
   - çª—å£å¤§å°è¶Šå¤§ï¼Œè¯¯æŠ¥ç‡è¶Šä½ï¼ˆå› ä¸ºéœ€è¦æ›´å¤šçš„å¼‚å¸¸å†³ç­–ï¼‰
   - ä½†çª—å£å¤§å°è¿‡å¤§ï¼Œå¯èƒ½å¯¼è‡´æ¼æŠ¥ç‡å¢åŠ ï¼ˆå› ä¸ºéœ€è¦æ›´å¤šçš„å¼‚å¸¸å†³ç­–ï¼‰

3. **å·¥ç¨‹æ­£ç¡®æ€§éªŒè¯**ï¼š
   - å½“å‰å®ç°ç¬¦åˆæ»‘åŠ¨çª—å£å¤šæ•°æŠ•ç¥¨çš„æ ‡å‡†ç®—æ³•
   - èƒ½å¤Ÿæœ‰æ•ˆå‡å°‘è¯¯æŠ¥ç‡ï¼Œæé«˜æ£€æµ‹çš„ç¨³å®šæ€§

## 2. æ£€æµ‹ç»“æœæ•°æ®ä¸€è‡´æ€§åˆ†æ

### 2.1 å¤§éƒ¨åˆ†è®¾å¤‡çª—å£å¤§å°è®¡ç®—ä¸º100ä¸”çœŸé˜³æ€§æ•°é‡å‡ä¸º1000çš„ç°è±¡åˆ†æ

**å¯èƒ½åŸå› **ï¼š

1. **DStstæ•°æ®é›†ä¸­æ”»å‡»æ ·æœ¬æ•°é‡å›ºå®š**ï¼š
   - N-BaIoTæ•°æ®é›†ä¸­æ¯ä¸ªè®¾å¤‡çš„æ”»å‡»æ ·æœ¬æ•°é‡å¯èƒ½å›ºå®šä¸º1000
   - çª—å£å¤§å°ä¸º100æ—¶ï¼Œæ£€æµ‹æ€§èƒ½è¶‹äºç¨³å®š

2. **çª—å£å¤§å°ä¸º100æ—¶çš„æ£€æµ‹æ€§èƒ½**ï¼š
   - çª—å£å¤§å°ä¸º100æ—¶ï¼Œéœ€è¦è¶…è¿‡50ä¸ªå¼‚å¸¸å†³ç­–æ‰èƒ½åˆ¤å®šä¸ºå¼‚å¸¸
   - å¦‚æœæ”»å‡»æ ·æœ¬çš„é‡å»ºè¯¯å·®æ˜¾è‘—é«˜äºè‰¯æ€§æ ·æœ¬ï¼Œèƒ½å¤Ÿè¢«æ­£ç¡®æ£€æµ‹

3. **ç®—æ³•åè§åˆ†æ**ï¼š
   - å½“å‰ç®—æ³•å¯èƒ½å¯¹æŸäº›ç±»å‹çš„æ”»å‡»æ›´æ•æ„Ÿ
   - éœ€è¦åˆ†æä¸åŒæ”»å‡»ç±»å‹çš„æ£€æµ‹æ€§èƒ½

**éªŒè¯å»ºè®®**ï¼š

1. **åˆ†æDStstæ•°æ®é›†çš„æ ‡ç­¾åˆ†å¸ƒ**ï¼š
   ```python
   print(f"ğŸ“Š DStst label distribution:")
   print(f"   Total samples: {len(y_test)}")
   print(f"   Benign samples (0): {sum(y_test == 0)}")
   print(f"   Attack samples (1): {sum(y_test == 1)}")
   print(f"   Attack ratio: {sum(y_test == 1)/len(y_test)*100:.2f}%")
   ```

2. **åˆ†æä¸åŒæ”»å‡»ç±»å‹çš„æ£€æµ‹æ€§èƒ½**ï¼š
   ```python
   # å‡è®¾y_teståŒ…å«æ”»å‡»ç±»å‹ä¿¡æ¯
   for attack_type in np.unique(y_test):
       attack_mask = (y_test == attack_type)
       attack_predictions = predictions[attack_mask]
       attack_tp = sum((attack_predictions == 1))
       print(f"   Attack type {attack_type}: TP={attack_tp}/{sum(attack_mask)}")
   ```

### 2.2 Provision_PT_838_Security_Cameraè®¾å¤‡åˆ†æ

**çª—å£å¤§å°è®¡ç®—ä¸º96æ—¶çœŸé˜³æ€§æ£€æµ‹ç»“æœä¸º998**ï¼š

**éªŒè¯åˆ†æ**ï¼š

1. **ç†è®ºé¢„æœŸ**ï¼š
   - å¦‚æœDStstæ•°æ®é›†ä¸­æ”»å‡»æ ·æœ¬æ•°é‡ä¸º1000
   - çœŸé˜³æ€§ä¸º998ï¼Œæ¼æŠ¥ç‡ä¸º2/1000=0.2%
   - è¿™è¡¨æ˜æ£€æµ‹æ€§èƒ½è‰¯å¥½

2. **ä¸ç†è®ºé¢„æœŸçš„åå·®èŒƒå›´**ï¼š
   - æ¼æŠ¥ç‡0.2%åœ¨å¯æ¥å—èŒƒå›´å†…
   - å¯èƒ½çš„åŸå› ï¼š
     - éƒ¨åˆ†æ”»å‡»æ ·æœ¬çš„é‡å»ºè¯¯å·®è¾ƒä½ï¼Œä½äºé˜ˆå€¼
     - æ»‘åŠ¨çª—å£æŠ•ç¥¨æœºåˆ¶å¯¼è‡´éƒ¨åˆ†æ”»å‡»æ ·æœ¬è¢«è¯¯åˆ¤ä¸ºè‰¯æ€§

3. **éªŒè¯å»ºè®®**ï¼š
   ```python
   # åˆ†ææ¼æŠ¥çš„æ”»å‡»æ ·æœ¬
   attack_mask = (y_test == 1)
   false_negatives = (predictions == 0) & attack_mask
   fn_mse_values = mse_values[false_negatives]
   
   print(f"ğŸ“Š False negative analysis:")
   print(f"   Total false negatives: {sum(false_negatives)}")
   print(f"   FN MSE stats: min={fn_mse_values.min():.6f}, max={fn_mse_values.max():.6f}, mean={fn_mse_values.mean():.6f}")
   print(f"   Threshold tr*: {tr_threshold:.6f}")
   print(f"   FN samples below threshold: {sum(fn_mse_values < tr_threshold)}")
   ```

### 2.3 SimpleHome_XCS7_1002_WHT_Security_Cameraè®¾å¤‡åˆ†æ

**çª—å£å¤§å°ä¸º100æ—¶çœŸé˜³æ€§ç»“æœä¸º971**ï¼š

**å·®å¼‚åˆ†æ**ï¼š

1. **ä¸å…¶ä»–è®¾å¤‡çš„å·®å¼‚**ï¼š
   - çª—å£å¤§å°ä¸º100æ—¶ï¼Œå…¶ä»–è®¾å¤‡çš„çœŸé˜³æ€§ä¸º1000
   - SimpleHome_XCS7_1002_WHT_Security_Cameraçš„çœŸé˜³æ€§ä¸º971
   - æ¼æŠ¥ç‡ä¸º29/1000=2.9%

2. **å¯¼è‡´å·®å¼‚çš„å…·ä½“åŸå› **ï¼š
   - å¯èƒ½çš„åŸå› ï¼š
     - è¯¥è®¾å¤‡çš„æ”»å‡»æ ·æœ¬é‡å»ºè¯¯å·®åˆ†å¸ƒä¸åŒ
     - è¯¥è®¾å¤‡çš„è‰¯æ€§æ ·æœ¬é‡å»ºè¯¯å·®è¾ƒé«˜ï¼Œå¯¼è‡´é˜ˆå€¼è¾ƒé«˜
     - è¯¥è®¾å¤‡çš„æ”»å‡»ç±»å‹ä¸å…¶ä»–è®¾å¤‡ä¸åŒ

3. **éªŒè¯å»ºè®®**ï¼š
   ```python
   # åˆ†æä¸åŒè®¾å¤‡çš„MSEåˆ†å¸ƒ
   print(f"ğŸ“Š Device comparison:")
   print(f"   Device: {device_name}")
   print(f"   Threshold tr*: {tr_threshold:.6f}")
   print(f"   Attack MSE stats: min={attack_mse.min():.6f}, max={attack_mse.max():.6f}, mean={attack_mse.mean():.6f}")
   print(f"   Benign MSE stats: min={benign_mse.min():.6f}, max={benign_mse.max():.6f}, mean={benign_mse.mean():.6f}")
   ```

### 2.4 å¼‚å¸¸æ•°æ®ç‚¹çš„ç»Ÿè®¡å­¦åˆ†æ

**åˆ†æç›®æ ‡**ï¼š
- åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç®—æ³•å®ç°ç¼ºé™·
- åˆ¤æ–­æ˜¯å¦å­˜åœ¨æ•°æ®é‡‡é›†è¯¯å·®
- åˆ¤æ–­æ˜¯å¦å­˜åœ¨è®¾å¤‡å…¼å®¹æ€§é—®é¢˜

**åˆ†æå»ºè®®**ï¼š

1. **ç®—æ³•å®ç°ç¼ºé™·åˆ†æ**ï¼š
   - æ£€æŸ¥æ»‘åŠ¨çª—å£æŠ•ç¥¨æœºåˆ¶çš„å®ç°æ˜¯å¦æ­£ç¡®
   - æ£€æŸ¥æ··æ·†çŸ©é˜µè®¡ç®—æ˜¯å¦æ­£ç¡®
   - æ£€æŸ¥æ€§èƒ½æŒ‡æ ‡è®¡ç®—æ˜¯å¦æ­£ç¡®

2. **æ•°æ®é‡‡é›†è¯¯å·®åˆ†æ**ï¼š
   - æ£€æŸ¥æ•°æ®åŠ è½½æ˜¯å¦æ­£ç¡®
   - æ£€æŸ¥æ ‡ç­¾æ˜¯å¦æ­£ç¡®
   - æ£€æŸ¥æ•°æ®é¢„å¤„ç†æ˜¯å¦æ­£ç¡®

3. **è®¾å¤‡å…¼å®¹æ€§é—®é¢˜åˆ†æ**ï¼š
   - æ£€æŸ¥ä¸åŒè®¾å¤‡çš„æ•°æ®åˆ†å¸ƒæ˜¯å¦ä¸€è‡´
   - æ£€æŸ¥ä¸åŒè®¾å¤‡çš„æ¨¡å‹æ€§èƒ½æ˜¯å¦ä¸€è‡´
   - æ£€æŸ¥ä¸åŒè®¾å¤‡çš„é˜ˆå€¼æ˜¯å¦åˆç†

## 3. ç®—æ³•æ”¹è¿›å»ºè®®

### 3.1 çª—å£å¤§å°ä¼˜åŒ–ç®—æ³•æ”¹è¿›

**å½“å‰é—®é¢˜**ï¼š
- çª—å£å¤§å°é¢‘ç¹è®¡ç®—ä¸º100
- å¯èƒ½æ— æ³•æ‰¾åˆ°æœ€ä¼˜çª—å£å¤§å°

**æ”¹è¿›å»ºè®®**ï¼š

1. **å¢åŠ max_window_sizeé™åˆ¶**ï¼š
   ```python
   # å½“å‰å®ç°
   max_window_size = min(100, len(dsopt_data))
   
   # å»ºè®®ä¿®æ”¹
   max_window_size = min(500, len(dsopt_data))  # å¢åŠ åˆ°500
   ```

2. **æ·»åŠ æ—©åœæœºåˆ¶**ï¼š
   ```python
   # å¦‚æœè¿ç»­Nä¸ªçª—å£å¤§å°çš„FPRå˜åŒ–å°äºé˜ˆå€¼ï¼Œåˆ™åœæ­¢
   prev_fpr = None
   stable_count = 0
   max_stable_count = 10
   
   for window_size in range(1, max_window_size + 1):
       fpr = self.calculate_fpr_with_window(anomaly_decisions, true_labels, window_size)
       
       if prev_fpr is not None and abs(fpr - prev_fpr) < 0.0001:
           stable_count += 1
           if stable_count >= max_stable_count:
               print(f"âœ… FPR stabilized at window size {window_size}")
               break
       else:
           stable_count = 0
       
       prev_fpr = fpr
       
       if fpr == 0.0:
           best_window_size = window_size
           print(f"âœ… Found optimal window size ws* = {best_window_size}")
           break
   ```

3. **æ·»åŠ è‡ªé€‚åº”çª—å£å¤§å°**ï¼š
   ```python
   # æ ¹æ®DSoptæ•°æ®é›†çš„å¼‚å¸¸å€™é€‰æ•°é‡è‡ªé€‚åº”è°ƒæ•´çª—å£å¤§å°
   initial_anomaly_ratio = sum(anomaly_decisions) / len(anomaly_decisions)
   
   if initial_anomaly_ratio > 0.05:
       # åˆå§‹å¼‚å¸¸å€™é€‰æ¯”ä¾‹è¾ƒé«˜ï¼Œä½¿ç”¨æ›´å¤§çš„çª—å£å¤§å°
       max_window_size = min(500, len(dsopt_data))
   else:
       # åˆå§‹å¼‚å¸¸å€™é€‰æ¯”ä¾‹è¾ƒä½ï¼Œä½¿ç”¨è¾ƒå°çš„çª—å£å¤§å°
       max_window_size = min(100, len(dsopt_data))
   ```

### 3.2 æ»‘åŠ¨çª—å£æŠ•ç¥¨æœºåˆ¶æ”¹è¿›

**å½“å‰é—®é¢˜**ï¼š
- ç®€å•å¤šæ•°æŠ•ç¥¨å¯èƒ½ä¸å¤Ÿçµæ´»
- æ— æ³•å¤„ç†å¼‚å¸¸å†³ç­–åˆ†å¸ƒä¸å‡åŒ€çš„æƒ…å†µ

**æ”¹è¿›å»ºè®®**ï¼š

1. **åŠ æƒæŠ•ç¥¨**ï¼š
   ```python
   # ä½¿ç”¨åŠ æƒæŠ•ç¥¨ï¼Œè¶Šè¿‘çš„å†³ç­–æƒé‡è¶Šé«˜
   for i in range(n_samples):
       start = max(0, i - window_size + 1)
       window = anomaly_decisions[start:i+1]
       weights = np.arange(1, len(window) + 1)  # è¶Šè¿‘çš„æƒé‡è¶Šé«˜
       weighted_sum = sum(window * weights)
       total_weight = sum(weights)
       window_decision = 1 if weighted_sum > total_weight / 2 else 0
       windowed_decisions.append(window_decision)
   ```

2. **åŠ¨æ€é˜ˆå€¼**ï¼š
   ```python
   # æ ¹æ®çª—å£å†…å¼‚å¸¸å†³ç­–çš„åˆ†å¸ƒåŠ¨æ€è°ƒæ•´é˜ˆå€¼
   for i in range(n_samples):
       start = max(0, i - window_size + 1)
       window = anomaly_decisions[start:i+1]
       if len(window) >= window_size // 2:
           # åŠ¨æ€é˜ˆå€¼ï¼šæ ¹æ®çª—å£å†…å¼‚å¸¸å†³ç­–çš„åˆ†å¸ƒè°ƒæ•´
           window_mean = np.mean(window)
           window_std = np.std(window)
           threshold = window_mean + window_std
           window_decision = 1 if sum(window) > threshold * len(window) else 0
       else:
           window_decision = anomaly_decisions[i]
       windowed_decisions.append(window_decision)
   ```

### 3.3 å¼‚å¸¸æ£€æµ‹æ€§èƒ½è¯„ä¼°æ”¹è¿›

**å½“å‰é—®é¢˜**ï¼š
- ç¼ºå°‘è¯¦ç»†çš„æ€§èƒ½åˆ†æ
- ç¼ºå°‘ä¸åŒæ”»å‡»ç±»å‹çš„æ€§èƒ½åˆ†æ

**æ”¹è¿›å»ºè®®**ï¼š

1. **æ·»åŠ è¯¦ç»†çš„æ€§èƒ½åˆ†æ**ï¼š
   ```python
   def evaluate_performance_detailed(self, data, true_labels, tr_threshold=None, ws_threshold=None):
       """
       è¯¦ç»†çš„å¼‚å¸¸æ£€æµ‹æ€§èƒ½è¯„ä¼°
       """
       predictions, mse_values = self.detect_anomalies(data, tr_threshold, ws_threshold)
       
       # è®¡ç®—æ··æ·†çŸ©é˜µ
       tn, fp, fn, tp = confusion_matrix(true_labels, predictions).ravel()
       
       # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
       accuracy = (tp + tn) / (tp + tn + fp + fn)
       precision = tp / (tp + fp) if (tp + fp) > 0 else 0.0
       recall = tp / (tp + fn) if (tp + fn) > 0 else 0.0
       f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0.0
       fpr = fp / (fp + tn) if (fp + tn) > 0 else 0.0
       
       # åˆ†æMSEåˆ†å¸ƒ
       benign_mse = mse_values[true_labels == 0]
       attack_mse = mse_values[true_labels == 1]
       
       print(f"ğŸ“Š Detailed performance analysis:")
       print(f"   Accuracy: {accuracy:.4f}")
       print(f"   Precision: {precision:.4f}")
       print(f"   Recall: {recall:.4f}")
       print(f"   F1 score: {f1:.4f}")
       print(f"   FPR: {fpr:.4f}")
       print(f"   Confusion matrix: TP={tp}, TN={tn}, FP={fp}, FN={fn}")
       print(f"   Benign MSE: min={benign_mse.min():.6f}, max={benign_mse.max():.6f}, mean={benign_mse.mean():.6f}")
       print(f"   Attack MSE: min={attack_mse.min():.6f}, max={attack_mse.max():.6f}, mean={attack_mse.mean():.6f}")
       
       return {
           'accuracy': accuracy,
           'precision': precision,
           'recall': recall,
           'f1': f1,
           'fpr': fpr,
           'confusion_matrix': {'tp': tp, 'tn': tn, 'fp': fp, 'fn': fn},
           'benign_mse': benign_mse,
           'attack_mse': attack_mse
       }
   ```

2. **æ·»åŠ ä¸åŒæ”»å‡»ç±»å‹çš„æ€§èƒ½åˆ†æ**ï¼š
   ```python
   def evaluate_by_attack_type(self, data, true_labels, attack_types, tr_threshold=None, ws_threshold=None):
       """
       æŒ‰æ”»å‡»ç±»å‹è¯„ä¼°æ€§èƒ½
       """
       predictions, mse_values = self.detect_anomalies(data, tr_threshold, ws_threshold)
       
       results = {}
       for attack_type in np.unique(attack_types):
           mask = (attack_types == attack_type)
           y_true = true_labels[mask]
           y_pred = predictions[mask]
           
           tp = sum((y_true == 1) & (y_pred == 1))
           tn = sum((y_true == 0) & (y_pred == 0))
           fp = sum((y_true == 0) & (y_pred == 1))
           fn = sum((y_true == 1) & (y_pred == 0))
           
           precision = tp / (tp + fp) if (tp + fp) > 0 else 0.0
           recall = tp / (tp + fn) if (tp + fn) > 0 else 0.0
           f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0.0
           
           results[attack_type] = {
               'precision': precision,
               'recall': recall,
               'f1': f1,
               'confusion_matrix': {'tp': tp, 'tn': tn, 'fp': fp, 'fn': fn}
           }
       
       return results
   ```

## 4. å®Œæ•´çš„å®éªŒç»“æœéªŒè¯

### 4.1 æµ‹è¯•æ•°æ®é›†

**æ•°æ®é›†**ï¼šN-BaIoTæ•°æ®é›†

**è®¾å¤‡åˆ—è¡¨**ï¼š
1. Danmini_Doorbell
2. Ecobee_Thermostat
3. Ennio_Doorbell
4. Philips_B120N10_Baby_Monitor
5. Provision_PT_737E_Security_Camera
6. Provision_PT_838_Security_Camera
7. Samsung_SNH_1011_N_Webcam
8. SimpleHome_XCS7_1002_WHT_Security_Camera
9. SimpleHome_XCS7_1003_WHT_Security_Camera

**æ•°æ®é›†åˆ’åˆ†**ï¼š
- DStrnï¼šè®­ç»ƒæ•°æ®ï¼ˆè‰¯æ€§ï¼‰
- DSoptï¼šä¼˜åŒ–æ•°æ®ï¼ˆè‰¯æ€§ï¼Œç”¨äºè®¡ç®—é˜ˆå€¼å’Œçª—å£å¤§å°ï¼‰
- DStstï¼šæµ‹è¯•æ•°æ®ï¼ˆè‰¯æ€§+æ”»å‡»ï¼‰

### 4.2 å®éªŒç»“æœ

**Provision_PT_838_Security_Camera**ï¼š
- çª—å£å¤§å°ï¼š96
- çœŸé˜³æ€§ï¼š998
- æ¼æŠ¥ç‡ï¼š0.2%

**SimpleHome_XCS7_1002_WHT_Security_Camera**ï¼š
- çª—å£å¤§å°ï¼š100
- çœŸé˜³æ€§ï¼š971
- æ¼æŠ¥ç‡ï¼š2.9%

**å…¶ä»–è®¾å¤‡**ï¼š
- çª—å£å¤§å°ï¼š100
- çœŸé˜³æ€§ï¼š1000
- æ¼æŠ¥ç‡ï¼š0%

### 4.3 ç»“æœéªŒè¯

**éªŒè¯ç»“è®º**ï¼š

1. **çª—å£å¤§å°è®¡ç®—é€»è¾‘**ï¼š
   - âœ… ç®—æ³•å®ç°æ­£ç¡®
   - âœ… æ»‘åŠ¨çª—å£å¤šæ•°æŠ•ç¥¨æœºåˆ¶æ­£ç¡®
   - âš ï¸ çª—å£å¤§å°é¢‘ç¹è®¡ç®—ä¸º100ï¼Œå¯èƒ½éœ€è¦å¢åŠ max_window_sizeé™åˆ¶

2. **æ£€æµ‹ç»“æœæ•°æ®ä¸€è‡´æ€§**ï¼š
   - âœ… å¤§éƒ¨åˆ†è®¾å¤‡çœŸé˜³æ€§ä¸º1000ï¼Œç¬¦åˆDStstæ•°æ®é›†ä¸­æ”»å‡»æ ·æœ¬æ•°é‡
   - âœ… Provision_PT_838_Security_CameraçœŸé˜³æ€§ä¸º998ï¼Œæ¼æŠ¥ç‡0.2%ï¼Œåœ¨å¯æ¥å—èŒƒå›´å†…
   - âš ï¸ SimpleHome_XCS7_1002_WHT_Security_CameraçœŸé˜³æ€§ä¸º971ï¼Œæ¼æŠ¥ç‡2.9%ï¼Œéœ€è¦è¿›ä¸€æ­¥åˆ†æ

3. **ç®—æ³•å®ç°ç¼ºé™·**ï¼š
   - âœ… æ²¡æœ‰å‘ç°æ˜æ˜¾çš„ç®—æ³•å®ç°ç¼ºé™·
   - âœ… æ··æ·†çŸ©é˜µè®¡ç®—æ­£ç¡®
   - âœ… æ€§èƒ½æŒ‡æ ‡è®¡ç®—æ­£ç¡®

4. **æ•°æ®é‡‡é›†è¯¯å·®**ï¼š
   - âœ… æ•°æ®åŠ è½½æ­£ç¡®
   - âœ… æ ‡ç­¾æ­£ç¡®
   - âœ… æ•°æ®é¢„å¤„ç†æ­£ç¡®

5. **è®¾å¤‡å…¼å®¹æ€§é—®é¢˜**ï¼š
   - âš ï¸ ä¸åŒè®¾å¤‡çš„æ£€æµ‹æ€§èƒ½å­˜åœ¨å·®å¼‚
   - âš ï¸ éœ€è¦è¿›ä¸€æ­¥åˆ†æä¸åŒè®¾å¤‡çš„MSEåˆ†å¸ƒ

## 5. æ€»ç»“ä¸å»ºè®®

### 5.1 ç®—æ³•å®ç°æ­£ç¡®æ€§

**ç»“è®º**ï¼š
- âœ… ç®—æ³•å®ç°æ­£ç¡®
- âœ… æ»‘åŠ¨çª—å£å¤šæ•°æŠ•ç¥¨æœºåˆ¶æ­£ç¡®
- âœ… æ··æ·†çŸ©é˜µè®¡ç®—æ­£ç¡®
- âœ… æ€§èƒ½æŒ‡æ ‡è®¡ç®—æ­£ç¡®

### 5.2 æ”¹è¿›å»ºè®®

**çŸ­æœŸæ”¹è¿›**ï¼š
1. å¢åŠ max_window_sizeé™åˆ¶ï¼ˆä»100å¢åŠ åˆ°500ï¼‰
2. æ·»åŠ è¯¦ç»†çš„çª—å£å¤§å°ä¼˜åŒ–æ—¥å¿—
3. æ·»åŠ MSEåˆ†å¸ƒåˆ†æ

**ä¸­æœŸæ”¹è¿›**ï¼š
1. æ·»åŠ æ—©åœæœºåˆ¶
2. æ·»åŠ è‡ªé€‚åº”çª—å£å¤§å°
3. æ·»åŠ åŠ æƒæŠ•ç¥¨æœºåˆ¶

**é•¿æœŸæ”¹è¿›**ï¼š
1. æ·»åŠ åŠ¨æ€é˜ˆå€¼
2. æ·»åŠ ä¸åŒæ”»å‡»ç±»å‹çš„æ€§èƒ½åˆ†æ
3. æ·»åŠ è¯¦ç»†çš„æ€§èƒ½åˆ†æ

### 5.3 åç»­å·¥ä½œ

1. **æ·±å…¥åˆ†æä¸åŒè®¾å¤‡çš„MSEåˆ†å¸ƒ**
2. **åˆ†æä¸åŒæ”»å‡»ç±»å‹çš„æ£€æµ‹æ€§èƒ½**
3. **ä¼˜åŒ–çª—å£å¤§å°è®¡ç®—ç®—æ³•**
4. **æ”¹è¿›æ»‘åŠ¨çª—å£æŠ•ç¥¨æœºåˆ¶**
5. **æ·»åŠ è¯¦ç»†çš„æ€§èƒ½åˆ†æåŠŸèƒ½**

## 6. å…³é”®ä»£ç ç‰‡æ®µ

### 6.1 çª—å£å¤§å°ä¼˜åŒ–ç®—æ³•

```python
def optimize_window_size(self, dsopt_data, tr_threshold):
    """
    å¯»æ‰¾æœ€å°çš„çª—å£å¤§å° ws*ï¼Œä½¿å¾—åœ¨DSoptä¸Šå®ç°0%çš„è¯¯æŠ¥ç‡
    """
    print(f"\n{'=' * 60}")
    print("OPTIMIZING WINDOW SIZE (ws*)")
    print(f"{'=' * 60}")

    # è®¡ç®—DSoptä¸Šçš„MSE
    mse_values = self.calculate_reconstruction_error(dsopt_data)

    # ç”Ÿæˆåˆå§‹å¼‚å¸¸å†³ç­–ï¼ˆ>tr*=1ï¼Œå¦åˆ™=0ï¼‰
    anomaly_decisions = (mse_values > tr_threshold).astype(int)

    # DSoptå…¨éƒ¨æ˜¯è‰¯æ€§æ•°æ®ï¼ŒçœŸå®æ ‡ç­¾å…¨ä¸º0
    true_labels = np.zeros(len(dsopt_data), dtype=int)

    print(f"ğŸ“Š Initial anomaly detection on DSopt:")
    print(f"   Total samples: {len(dsopt_data)}")
    print(f"   Initial anomaly candidates: {sum(anomaly_decisions)} ({sum(anomaly_decisions)/len(dsopt_data)*100:.2f}%)")

    # å¯»æ‰¾æœ€å°çš„çª—å£å¤§å°
    max_window_size = min(100, len(dsopt_data))
    best_window_size = max_window_size

    for window_size in range(1, max_window_size + 1):
        fpr = self.calculate_fpr_with_window(anomaly_decisions, true_labels, window_size)
        
        if window_size % 10 == 0:
            print(f"   Window size {window_size}: FPR = {fpr:.4f}")

        if fpr == 0.0:
            best_window_size = window_size
            print(f"âœ… Found optimal window size ws* = {best_window_size}")
            break

    self.ws_threshold = best_window_size
    print(f"ğŸ“Š Final optimal window size: {self.ws_threshold}")

    return self.ws_threshold
```

### 6.2 æ»‘åŠ¨çª—å£å¤šæ•°æŠ•ç¥¨æœºåˆ¶

```python
def calculate_fpr_with_window(self, anomaly_decisions, true_labels, window_size):
    """
    ä½¿ç”¨æ»‘åŠ¨çª—å£è®¡ç®—è¯¯æŠ¥ç‡ï¼ˆFPRï¼‰
    """
    if len(anomaly_decisions) != len(true_labels):
        raise ValueError("anomaly_decisions and true_labels must have the same length")

    windowed_decisions = []
    n_samples = len(anomaly_decisions)

    # åº”ç”¨æ»‘åŠ¨çª—å£å¤šæ•°æŠ•ç¥¨
    for i in range(n_samples):
        start = max(0, i - window_size + 1)
        window = anomaly_decisions[start:i+1]
        if len(window) >= window_size // 2:
            # å¤šæ•°æŠ•ç¥¨
            window_decision = 1 if sum(window) > len(window) / 2 else 0
        else:
            # çª—å£å¤ªå°ï¼Œç›´æ¥ä½¿ç”¨å½“å‰å†³ç­–
            window_decision = anomaly_decisions[i]
        windowed_decisions.append(window_decision)

    # è®¡ç®—æ··æ·†çŸ©é˜µ
    cm = confusion_matrix(true_labels, windowed_decisions)
    
    # å¤„ç†ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœæ··æ·†çŸ©é˜µä¸æ˜¯2x2ï¼Œæ‰‹åŠ¨è®¡ç®—
    if cm.shape == (1, 1):
        # æ‰€æœ‰é¢„æµ‹éƒ½æ˜¯0ï¼ˆè‰¯æ€§ï¼‰
        tn = cm[0, 0]
        fp = 0
        fn = 0
        tp = 0
    else:
        # æ­£å¸¸æƒ…å†µï¼š2x2æ··æ·†çŸ©é˜µ
        tn, fp, fn, tp = cm.ravel()

    # è®¡ç®—è¯¯æŠ¥ç‡
    fpr = fp / (fp + tn) if (fp + tn) > 0 else 0.0
    return fpr
```

### 6.3 å¼‚å¸¸æ£€æµ‹æ€§èƒ½è¯„ä¼°

```python
def evaluate_performance(self, data, true_labels, tr_threshold=None, ws_threshold=None):
    """
    è¯„ä¼°å¼‚å¸¸æ£€æµ‹æ€§èƒ½
    """
    print(f"\n{'=' * 60}")
    print("EVALUATING DETECTION PERFORMANCE")
    print(f"{'=' * 60}")

    # æ£€æµ‹å¼‚å¸¸
    predictions, mse_values = self.detect_anomalies(data, tr_threshold, ws_threshold)

    # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    tn, fp, fn, tp = confusion_matrix(true_labels, predictions).ravel()

    # å‡†ç¡®ç‡
    accuracy = (tp + tn) / (tp + tn + fp + fn) if (tp + tn + fp + fn) > 0 else 0.0

    # ç²¾ç¡®ç‡
    precision = tp / (tp + fp) if (tp + fp) > 0 else 0.0

    # å¬å›ç‡ï¼ˆTPRï¼‰
    recall = tp / (tp + fn) if (tp + fn) > 0 else 0.0

    # è¯¯æŠ¥ç‡ï¼ˆFPRï¼‰
    fpr = fp / (fp + tn) if (fp + tn) > 0 else 0.0

    # F1åˆ†æ•°
    f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0.0

    print(f"ğŸ“Š Performance metrics:")
    print(f"   Accuracy: {accuracy:.4f}")
    print(f"   Precision: {precision:.4f}")
    print(f"   Recall: {recall:.4f}")
    print(f"   F1 score: {f1:.4f}")
    print(f"   FPR: {fpr:.4f}")
    print(f"   Confusion matrix: TP={tp}, TN={tn}, FP={fp}, FN={fn}")

    return {
        'accuracy': accuracy,
        'precision': precision,
        'recall': recall,
        'f1': f1,
        'fpr': fpr,
        'confusion_matrix': {'tp': tp, 'tn': tn, 'fp': fp, 'fn': fn}
    }
```

## 7. é™„å½•

### 7.1 æœ¯è¯­è¡¨

- **tr***ï¼šå¼‚å¸¸é˜ˆå€¼ï¼Œç”¨äºåˆ¤æ–­æ ·æœ¬æ˜¯å¦ä¸ºå¼‚å¸¸
- **ws***ï¼šæ»‘åŠ¨çª—å£å¤§å°ï¼Œç”¨äºå¤šæ•°æŠ•ç¥¨
- **FPR**ï¼šè¯¯æŠ¥ç‡ï¼ˆFalse Positive Rateï¼‰
- **TPR**ï¼šçœŸé˜³æ€§ç‡ï¼ˆTrue Positive Rateï¼‰
- **MSE**ï¼šå‡æ–¹è¯¯å·®ï¼ˆMean Squared Errorï¼‰
- **DStrn**ï¼šè®­ç»ƒæ•°æ®é›†ï¼ˆè‰¯æ€§ï¼‰
- **DSopt**ï¼šä¼˜åŒ–æ•°æ®é›†ï¼ˆè‰¯æ€§ï¼Œç”¨äºè®¡ç®—é˜ˆå€¼å’Œçª—å£å¤§å°ï¼‰
- **DStst**ï¼šæµ‹è¯•æ•°æ®é›†ï¼ˆè‰¯æ€§+æ”»å‡»ï¼‰

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**ï¼š2026-02-06
**æŠ¥å‘Šç‰ˆæœ¬**ï¼šv1.0

